//////////////////////////////////////////////
// Модуль общего функционала		        //
// Версия: 1.0.0.1					        //
// Автор: Лелеко Никита, Дата: 17.12.2014	//
//////////////////////////////////////////////

#Область Стандартные

// Получение Н-го элемента коллекции
// Параметры:
//  Коллекция  	- коллекция - последовательно обрабатываемая коллекция
//  Индекс 		- число(целое) - индекс требуемого элемента коллекции
//  ЕслиНеНайдено - ? - значение, возвращаемое в случае если не найден элемент
// Возвращаемое значение:
//  ? - значение
// Проверено: 
Функция Получить(Коллекция, Индекс = 0, ЕслиНеНайдено = Неопределено) Экспорт
	Сч = -1;
	Для Каждого Элемент Из Коллекция Цикл
		Сч = Сч + 1;
		Если Сч = Индекс Тогда
			Возврат Элемент;
		КонецЕсли;
	КонецЦикла;
КонецФункции

// Получение массива элементов коллекции, М-элементов, начиная С
// Параметры:
//  Коллекция  	- коллекция - последовательно обрабатываемая коллекция
//  НачатьС 	- число(целое) - индекс начального элемента
//  Взять 		- число(целое) - число возвращаемых элементов (при выходе за границу массива - игнорировать)
// Возвращаемое значение:
//  Массив - массив элементов
Функция Срез(Коллекция, Индекс = 0, Взять = -1) Экспорт
	Результат		= Новый Массив();
	СчИндекс	 	= 0;
	СчВзять 		= 0;
	
	Для Каждого Элемент Из Коллекция Цикл
		Если СчИндекс < Индекс Тогда
			СчИндекс = СчИндекс + 1;
			Продолжить;
		ИначеЕсли СчВзять <> Взять Тогда 
			Результат.Добавить(Элемент);
			СчВзять = СчВзять + 1;
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;	
КонецФункции

// Получение массива элементов коллекции, М-элементов, начиная С
// Параметры:
//  Коллекция  			- коллекция - последовательно обрабатываемая коллекция
//  ВыражениеПроверки 	- строка - вычислимое выражение [Элемент] => Булево
//  Взять 		- число(целое) - число возвращаемых элементов (при выходе за границу массива - игнорировать)
// Возвращаемое значение:
//  Массив - массив элементов, удовлетворяющих выражению
Функция Где(Коллекция, ВыражениеПроверки = "Элемент <> Неопределено") Экспорт
	Результат = Новый Массив;
	Для Каждого Элемент Из Коллекция Цикл
		Если Вычислить(ВыражениеПроверки) Тогда
			Результат.Добавить(Элемент);
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;	
КонецФункции

// Преобразует коллекцию в массив
// Параметры:
//  Коллекция  	- коллекция - последовательно обрабатываемая коллекция
//	ВыражениеОтображения 	- строка - вычислимое выражение [Элемент] => ?
// Возвращаемое значение:
//  Массив - массив преобразованных элементов
Функция Отобразить(Коллекция, ВыражениеОтображения = "Элемент") Экспорт
	Результат = Новый Массив;
	Для Каждого Элемент Из Коллекция Цикл
		Результат.Добавить(Вычислить(ВыражениеОтображения));
	КонецЦикла;
	Возврат Результат;
КонецФункции

// Преобразует коллекцию в массив
// Параметры:
//  Коллекция  	- коллекция - последовательно обрабатываемая коллекция
// Возвращаемое значение:
//  Массив - массив 
Функция ВМассив(Коллекция) Экспорт
	Результат = Новый Массив;
	Для Каждого Элемент Из Коллекция Цикл
		Результат.Добавить(Элемент);
	КонецЦикла;
	Возврат Результат;
КонецФункции

// Создает массив и копирует в него значения, содержащиеся в колонке коллекции строк
// Параметры:
//	Коллекция - коллекция, для которой доступен обход посредством  
//		оператора Для каждого … Из … Цикл
//	ИмяСвойства - строка с именем поля коллекции, значения которого нужно выгрузить
//	ТолькоУникальныеЗначения - булево, необязательный, если истина, 
//		то в массив будут включены только различающиеся значения 
// Возвращаемое значение:
//  Массив - массив значений
Функция Свойство(Коллекция, ИмяСвойства, ТолькоУникальныеЗначения = Ложь) Экспорт

	МассивЗначений = Новый Массив;
	
	Если ТолькоУникальныеЗначения Тогда
		УникальныеЗначения = Новый Соответствие;
		Для каждого Элемент Из Коллекция Цикл
			Значение = Элемент[ИмяСвойства];
			Если ТолькоУникальныеЗначения И УникальныеЗначения[Значение] <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			МассивЗначений.Добавить(Значение);
			УникальныеЗначения.Вставить(Значение, Истина);
		КонецЦикла;
	Иначе
		Для каждого Элемент Из Коллекция Цикл
			Значение = Элемент[ИмяСвойства];
			МассивЗначений.Добавить(Значение);
		КонецЦикла;
	КонецЕсли;
	
	Возврат МассивЗначений;
КонецФункции

#КонецОбласти

#Область Экстремумы

// Функция позволяет получать экстремум по св-ву коллекции
// Параметры:
//  Коллекция  - коллекция - последовательно обрабатываемая коллекция
//  ТипЭкстремума  - строка {Макс,Мин} - тип экстремума
//  ИмяСвойства  - строка/неопределено - имя св-ва если элементами коллекции являются сложные объекты
//  НачальноеЗначение - ? - значение по-умолчанию с которого будет начинаться сравнение
//	ВозврИндекс - число - индекс найденного значения {-1}, если значение не найдено
// Возвращаемое значение:
//  ? - значение экстремума
Функция Экстремум(Коллекция, ВыражениеЭкстремума = "Макс(а,б)", ВыражениеКлюча = "Элемент", Знач НачальноеЗначение = Неопределено, ВозврИндекс = Неопределено) Экспорт
	Индекс			= -1;
	ВозврИндекс 	= -1;
	
	Для Каждого Элемент Из Коллекция Цикл
		Индекс 		= Индекс + 1;
		Значение 	= Вычислить(ВыражениеКлюча);
		а 			= НачальноеЗначение;
		б 			= Значение;
		Если а = Неопределено ИЛИ Значение = Вычислить(ВыражениеЭкстремума) Тогда
			НачальноеЗначение 	= Значение;
			ВозврИндекс 		= Индекс;
		КонецЕсли;
	КонецЦикла;
	
	Возврат НачальноеЗначение;
КонецФункции

// Создание параметра для агрегации (применяется с "Агрегация")
// Параметры: 
//	Параметры - структура - структура для добавления в нее параметров
//	ИмяПараметра - строка - имя параметра в который будет агрегироваться выражение
//	ВыражениеАгрегации - строка - вычислимое выражение [а,б] => ?
//	ВыражениеКлюча - строка - вычислимое выражение [Элемент(%ИмяПараметра%)] => ?
//	НачальноеЗначение - ? - стартовое значение агрегации
// Возвращаемое значение:
//  Структура - структура, содержащая параметры агрегации
Функция СоздатьАгрПараметр(Параметры = Неопределено, ИмяПараметра, ВыражениеАгрегации = "Макс(а,б)", ВыражениеКлюча = "Элемент.%ИмяПараметра%", НачальноеЗначение = Неопределено) Экспорт
	
	Подпараметры = Новый Структура();
	Подпараметры.Вставить("ВыражениеАгрегации", ВыражениеАгрегации);
	Подпараметры.Вставить("ВыражениеКлюча", СтрЗаменить(ВыражениеКлюча, "%ИмяПараметра%", ИмяПараметра));
	Подпараметры.Вставить("НачальноеЗначение", НачальноеЗначение);
	
	Если Параметры = Неопределено Тогда
		Параметры = Новый Структура();
	КонецЕсли;
	
	Параметры.Вставить(ИмяПараметра, Подпараметры);
	Возврат Параметры;
КонецФункции

// Агрегация коллекции по нескольким выражениям за один проход
// Возвращаемое значение:
//  Структура - структура, содержащая результаты агрегации в соответсвии с переданными параметрами
Функция Агрегация(Коллекция, Параметры = "Тут сложно! Читай хэлп") Экспорт
	Ст = Новый Структура;
	
	Для Каждого ПолеВычисление Из Параметры Цикл
		Подпараметры = ПолеВычисление.Значение;
		Ст.Вставить(ПолеВычисление.Ключ, Подпараметры.НачальноеЗначение);
	КонецЦикла;
	
	Для Каждого Элемент Из Коллекция Цикл
		Для Каждого ПолеВычисление Из Параметры Цикл
			Ключ 			= ПолеВычисление.Ключ;
			Подпараметры 	= ПолеВычисление.Значение;
			
			Значение 		= Вычислить(Подпараметры.ВыражениеКлюча);
			а 				= Ст[Ключ];
			б 				= Значение;
			
			Если а = Неопределено Тогда
				Ст[Ключ]	= б;
			Иначе
				Ст[Ключ] 	= Вычислить(Подпараметры.ВыражениеАгрегации);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Возврат Ст;
КонецФункции

#КонецОбласти

#Область Индексирование

// Получает индексированное соответствие для доступа вида [Свойство_1][Свойство_2][...] => Массив
// Параметры:
//	Коллекция - коллекция, для которой доступен обход посредством  
//		оператора Для каждого … Из … Цикл
//	ИменаСвойств - строка с именами полей, по которым устанавливается уникальность
// Возвращаемое значение:
//  Соответсвие - соответствие для доступа вида [Свойство_1][Свойство_2][...] => Массив
Функция Индексировать(Коллекция, ИменаСвойств) Экспорт
	
	ВерхнийСловарь 		= Новый Соответствие;
	СтруктураКлючей		= Новый Структура(ИменаСвойств);
	КоличествоСвойств 	= СтруктураКлючей.Количество();
	
	Для Каждого Элемент Из Коллекция Цикл
		
		СтруктураЗначений = Новый Структура(ИменаСвойств);
		ЗаполнитьЗначенияСвойств(СтруктураЗначений, Элемент);
		
		ТекущийСловарь 		= ВерхнийСловарь;
		СледующийУзел		= Неопределено;
		ЦепочкаПрервана		= Ложь;
		СчНомерСвойства		= 0;
		
		Для Каждого КлючКлючей Из СтруктураКлючей Цикл
			Ключ 			= КлючКлючей.Ключ;
			Значение 		= СтруктураЗначений[Ключ];
			СчНомерСвойства	= СчНомерСвойства + 1;
			Если ЦепочкаПрервана Тогда
				СледующийУзел = ?(СчНомерСвойства = КоличествоСвойств, Новый Массив, Новый Соответствие);
				ТекущийСловарь.Вставить(Значение, СледующийУзел);
			Иначе
				СледующийУзел = ТекущийСловарь.Получить(Значение);
				Если СледующийУзел = Неопределено Тогда 
					ЦепочкаПрервана = Истина;
					СледующийУзел 	= ?(СчНомерСвойства = КоличествоСвойств, Новый Массив, Новый Соответствие);
					ТекущийСловарь.Вставить(Значение, СледующийУзел);
				КонецЕсли;
			КонецЕсли;
			ТекущийСловарь = СледующийУзел;
		КонецЦикла;
		Если СледующийУзел <> Неопределено Тогда
			СледующийУзел.Добавить(Элемент);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ВерхнийСловарь;
КонецФункции

// Получает соответствие для вида [СтруктураКлючей] => Массив
// Параметры:
//	Коллекция - коллекция, для которой доступен обход посредством  
//		оператора Для каждого … Из … Цикл
//	ИменаСвойств - строка с именами полей, по которым устанавливается уникальность
// Возвращаемое значение:
//  Соответсвие - соответствие вида [СтруктураКлючей] => Массив
Функция Группировать(Коллекция, ИменаСвойств) Экспорт
	
	ПлоскийСловать		= Новый Соответствие;
	ВерхнийСловарь 		= Новый Соответствие;
	СтруктураКлючей		= Новый Структура(ИменаСвойств);
	КоличествоСвойств 	= СтруктураКлючей.Количество();
	
	Для Каждого Элемент Из Коллекция Цикл
		
		СтруктураЗначений = Новый Структура(ИменаСвойств);
		ЗаполнитьЗначенияСвойств(СтруктураЗначений, Элемент);
		
		ТекущийСловарь 		= ВерхнийСловарь;
		СледующийУзел		= Неопределено;
		ЦепочкаПрервана		= Ложь;
		СчНомерСвойства		= 0;
		
		Для Каждого КлючКлючей Из СтруктураКлючей Цикл
			Ключ 			= КлючКлючей.Ключ;
			Значение 		= СтруктураЗначений[Ключ];
			СчНомерСвойства	= СчНомерСвойства + 1;
			Если ЦепочкаПрервана Тогда
				Если СчНомерСвойства = КоличествоСвойств Тогда
					СледующийУзел = Новый Массив;
					ПлоскийСловать.Вставить(СтруктураЗначений, СледующийУзел); 
				Иначе
					СледующийУзел = Новый Соответствие;
				КонецЕсли;
				ТекущийСловарь.Вставить(Значение, СледующийУзел);
			Иначе
				СледующийУзел = ТекущийСловарь.Получить(Значение);
				Если СледующийУзел = Неопределено Тогда 
					ЦепочкаПрервана = Истина;
					Если СчНомерСвойства = КоличествоСвойств Тогда
						СледующийУзел = Новый Массив;
						ПлоскийСловать.Вставить(СтруктураЗначений, СледующийУзел); 
					Иначе
						СледующийУзел = Новый Соответствие;
					КонецЕсли;
					ТекущийСловарь.Вставить(Значение, СледующийУзел);
				КонецЕсли;
			КонецЕсли;
			ТекущийСловарь = СледующийУзел;
		КонецЦикла;
		Если СледующийУзел <> Неопределено Тогда
			СледующийУзел.Добавить(Элемент);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ПлоскийСловать;
КонецФункции

// Получает индексированное соответствие для доступа вида [Свойство_1][Свойство_2][...] => Массив
// Параметры:
//	Коллекция - коллекция, для которой доступен обход посредством  
//		оператора Для каждого … Из … Цикл
//	ИменаСвойств - строка с именами полей, по которым устанавливается уникальность
// Возвращаемое значение:
//  Соответсвие - соответствие для доступа вида [Свойство_1][Свойство_2][...] => Массив
Функция ГруппироватьПоКлючу(Коллекция, ВыражениеКлюча = "Элемент") Экспорт
	Словарь = Новый Соответствие();
	
	Для Каждого Элемент Из Коллекция Цикл
		Ключ = Вычислить(ВыражениеКлюча);
		МассивЗначений = Словарь[Ключ];
		Если МассивЗначений = Неопределено Тогда
			МассивЗначений = Новый Массив();
			Словарь.Вставить(Ключ, МассивЗначений);
		КонецЕсли;
		МассивЗначений.Добавить(Элемент);
	КонецЦикла;
	
	Возврат Словарь;
КонецФункции

// Получает коллекцю элементов различающуюся по указанным св-вам
// для совпадающих эелементов, возвращается 1й элемент
// Параметры:
//	Коллекция - коллекция, для которой доступен обход посредством  
//		оператора Для каждого … Из … Цикл
//	ИменаСвойств - строка с именами полей, по которым устанавливается уникальность
// Возвращаемое значение:
//  Массив - массив значений
Функция Различные(Коллекция, ИменаСвойств) Экспорт
	
	МассивЗначений 		= Новый Массив;	
	Если Коллекция = Неопределено Тогда Возврат МассивЗначений; КонецЕсли;
	
	ВерхнийСловарь 		= Новый Соответствие;
	СтруктураКлючей		= Новый Структура(ИменаСвойств);
	КоличествоСвойств 	= СтруктураКлючей.Количество();
	
	Для Каждого Элемент Из Коллекция Цикл
		
		СтруктураЗначений = Новый Структура(ИменаСвойств);
		ЗаполнитьЗначенияСвойств(СтруктураЗначений, Элемент);
		
		ТекущийСловарь 		= ВерхнийСловарь;
		ЦепочкаПрервана		= Ложь;
		СчНомерСвойства		= 0;
		
		Для Каждого КлючКлючей Из СтруктураКлючей Цикл
			Ключ 			= КлючКлючей.Ключ;
			Значение 		= СтруктураЗначений[Ключ];
			СчНомерСвойства	= СчНомерСвойства + 1;
			Если ЦепочкаПрервана Тогда
				СледующийСловарь = ?(СчНомерСвойства = КоличествоСвойств, Истина, Новый Соответствие());
				ТекущийСловарь.Вставить(Значение, СледующийСловарь);
			Иначе
				СледующийСловарь = ТекущийСловарь.Получить(Значение);
				Если СледующийСловарь = Неопределено Тогда 
					МассивЗначений.Добавить(Элемент);
					ЦепочкаПрервана 	= Истина;
					СледующийСловарь 	= ?(СчНомерСвойства = КоличествоСвойств, Истина, Новый Соответствие());
					ТекущийСловарь.Вставить(Значение, СледующийСловарь);
				КонецЕсли;
			КонецЕсли;
			ТекущийСловарь = СледующийСловарь;
		КонецЦикла;
		
	КонецЦикла;

	Возврат МассивЗначений; 
КонецФункции

// Получает коллекцю элементов различающуюся по вычислимому ключу
// для совпадающих эелементов, возвращается 1й элемент
// Параметры:
//	Коллекция - коллекция, для которой доступен обход посредством  
//		оператора Для каждого … Из … Цикл
//	ИменаСвойств - строка с именами полей, по которым устанавливается уникальность
// Возвращаемое значение:
//  Массив - массив значений
Функция РазличныеПоКлючу(Коллекция, ВыражениеКлюча = "Элемент") Экспорт
	МассивЗначений 		= Новый Массив;	
	Если Коллекция = Неопределено Тогда Возврат МассивЗначений; КонецЕсли;
	
	УникальныеЗначения 	= Новый Соответствие;
	Для Каждого Элемент Из Коллекция Цикл
		Ключ = Вычислить(ВыражениеКлюча);
		Если УникальныеЗначения[Ключ] <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		МассивЗначений.Добавить(Элемент);
		УникальныеЗначения.Вставить(Ключ, Истина);
	КонецЦикла;

	Возврат МассивЗначений;	
КонецФункции

#КонецОбласти

Функция ДляКаждогоИз(Коллекция, Ст = Неопределено, ВыражениеКаждого = "Ст.Сумма = Ст.Сумма + Элемент", ВыражениеВозврата = "Истина") Экспорт
	Если Коллекция <> Неопределено Тогда
		Для Каждого Элемент Из Коллекция Цикл
			Выполнить(ВыражениеКаждого);
		КонецЦикла;
	КонецЕсли;
	Возврат Вычислить(ВыражениеВозврата);
КонецФункции

Функция ОтобразитьСвернуть(Коллекция, ВыражениеКлюча = "Элемент", ВыражениеИнициализации = "0", ВыражениеСворачивания = "Значение + 1") Экспорт
	Словарь = Новый Соответствие();
	
	Для Каждого Элемент Из Коллекция Цикл
		Ключ = Вычислить(ВыражениеКлюча);
		Значение = Словарь[Ключ];
		Если Значение = Неопределено Тогда
			Значение = Вычислить(ВыражениеИнициализации);
			Словарь.Вставить(Ключ, Значение);
		КонецЕсли;
		Словарь[Ключ] = Вычислить(ВыражениеСворачивания);
	КонецЦикла;	
	
КонецФункции

Функция СхемаРасхожденийПоКлючу(КоллекцияА, ВыражениеКлючаА = "а", КоллекцияБ, ВыражениеКлючаБ = "б") Экспорт
	МассивТолькоА = Новый Массив();
	МассивТолькоБ = Новый Массив();
		
	Словарь = Новый Структура();
	Словарь.Вставить("ТолькоА",МассивТолькоА);
	Словарь.Вставить("ТолькоБ",МассивТолькоБ);
	
	КлючиБ = Новый Соответствие();
	
	Для Каждого б Из КоллекцияБ Цикл
		Ключ = Вычислить(ВыражениеКлючаБ);
		Если КлючиБ[Ключ] = Неопределено Тогда
			КлючиБ.Вставить(Ключ, Ложь);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого а Из КоллекцияА Цикл
		КлючА = Вычислить(ВыражениеКлючаА);
		Значение = КлючиБ[Ключ];
		Если Значение = Неопределено Тогда
			МассивТолькоА.Добавить(а);
		ИначеЕсли Значение = Ложь Тогда
			КлючиБ[Ключ] = Истина;
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого б Из КоллекцияБ Цикл
		Ключ = Вычислить(ВыражениеКлючаБ);
		Если КлючиБ[Ключ] = Ложь Тогда
			МассивТолькоБ.Добавить(б);
		КонецЕсли;
	КонецЦикла; 
	
КонецФункции

#Область СТРОКОВЫЕ

// Конкатенация
// Параметры:
//  Коллекция  	- коллекция - последовательно обрабатываемая коллекция
//  Разделитель - строка - разделитель элементов
//  ИгнорироватьПустые - булево - признак необходимости включения в результат пустых строк
//  ВыражениеОтображения - строка - вычислимое выражение [Элемент] => Строка
// Возвращаемое значение:
//  Строка - объединенная строка
Функция Конкатенация(Коллекция, Разделитель = ",", ИгнорироватьПустые = Ложь, ВыражениеОтображения = "Строка(Элемент)") Экспорт
	Стр 				= "" ;
	СимволРазделителя 	= Ложь;
	
	Для Каждого Элемент Из Коллекция Цикл
		Значение = Вычислить(ВыражениеОтображения);
		Если ИгнорироватьПустые И ПустаяСтрока(Значение) Тогда
			Продолжить;
		КонецЕсли;
		Если СимволРазделителя = Ложь Тогда
			Стр = Стр + Значение;
			СимволРазделителя = Истина;
		Иначе
			Стр = Стр + Разделитель + Значение;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Стр;
КонецФункции

#КонецОбласти